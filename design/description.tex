\section{Protocol Description}



This protocol begins with entity $A$ generating a nonce, denoted as $N_A$. $A$ then encrypts her identity together
with the nonce using the freshly generated session key $K_{AB}$. The transmitted data is structured as follows:
$\{|A,N_A|\}_{K_{AB}}$. This message costs \textbf{63}.

\vspace{1cm}

After sending the first message, $A$ sends to the honest and trusted server $S$, using the shared key $K_{AS}$,
the identity of $B$, a timestamp $\tau$, a lifetime period to confirm the key $\lambda$ and the session key $K_{AB}$.
The transmitted data is structured as follows: $\{|B, \tau, \lambda, K_{AB}|\}_{K_{AS}}$. This message costs \textbf{166}.

\vspace{1cm}

Then $S$, using the shared key $K_{BS}$, sends to $B$ essentially the same message, but with $A$ replaced by $B$.
The transmitted data is structured as follows: $\{|A, \tau, \lambda, K_{AB}|\}_{K_{BS}}$. This message costs: \textbf{166}.

\vspace{1cm}

$B$ receives the message $\{|A, \tau, \lambda, K_{AB}|\}_{K_{BS}}$ and obtains the session key $K_{AB}$.
He also learns the validity period $\lambda$, starting from time $\tau$, during which $A$ will accept his response.
This measure provides protection against ticket theft. Indeed, even if an attacker manages to intercept a ticket,
they will not be able to use it after its expiration.

Then $B$ respond to the first message of $A$, he can decrypt the nonce $\{|N_A|\}_{K_{AB}}$ with the session key.
Key confirmation lies in the fact that $B$ sends back $N_A + 1$ to $A$. In this way, $A$ knows that $B$ has successfully
retrieved the key. This allows combining key confirmation with the challengeâ€“response mechanism for the authentication
of $B$ with respect to $A$. The transmitted data is structured as follows: $\{| N_A + 1|\}_{K_{AB}}$. This message costs \textbf{12}.



\vspace{1cm}

The total cost is: \textbf{409}.